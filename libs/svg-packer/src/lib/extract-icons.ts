import * as path from 'node:path';
import * as fs from 'node:fs/promises';
// import { $ } from 'execa';
import * as fsExtra from 'fs-extra';
import { glob } from 'glob';
import { parse } from 'node-html-parser';
import { debug, log, success, warn } from './log';

const comment = `** DO NOT EDIT ** This file is generated by alx-svg-packer`

export class ExtractIconsCmd {
  constructor(public inputDir: string, public outputDir: string, public opts: {
    force?: boolean,
    typeName: string
    typeOutput?: string;
    svgFilename: string;
    typeFilename: string;
  }) {}

  async execute() {
    await fsExtra.ensureDir(this.outputDir);
    if (this.opts.typeOutput) {
      await fsExtra.ensureDir(this.opts.typeOutput);
    }

    const files = await glob('**/*.svg', {
      cwd: this.inputDir,
    }).then((s) => s.sort((a, b) => a.localeCompare(b)));

    if (files.length === 0) {
      warn(`Operation Canceled: No SVG files found in the path: '${this.inputDir}'`);
      return;
    }

    await this.generateIconFiles(files);
  }

  private async generateIconFiles(files: string[]) {
    const spriteFilepath = path.join(this.outputDir, `${this.opts.svgFilename}.svg`);
    const typeOutputFilepath = path.join((this.opts.typeOutput ?? this.outputDir), `${this.opts.typeFilename}.d.ts`);
    const iconNames = files.map((file) => this.iconName(file));

    if (!this.opts.force) {
      const currentSprite = await fs
        .readFile(spriteFilepath, { encoding: 'utf8' })
        .catch(() => '');
      const currentTypes = await fs
        .readFile(typeOutputFilepath, { encoding: 'utf8' })
        .catch(() => '');

      const spriteUpToDate = iconNames.every((name) =>
        currentSprite.includes(`id="${name}"`)
      );
      const typesUpToDate = iconNames.every((name) =>
        currentTypes.includes(`"${name}"`)
      );

      if (spriteUpToDate && typesUpToDate) {
        log(`Icons are up to date`);
        return;
      }
    }

    debug(`Generating sprite for ${this.inputDir}`);

    const spriteChanged = await this.generateSvgSprite({
      files,
      inputDir: this.inputDir,
      outputPath: spriteFilepath,
    });

    for (const file of files) {
      debug('âœ… ', file);
    }
    debug(`Saved to ${this.outputDir}`);

    const stringifiedIconNames = iconNames.map((name) => JSON.stringify(name));

    const typeOutputContent = `// ${comment}

export type ${this.opts.typeName} =
\t| ${stringifiedIconNames.join('\n\t| ')};
`;
    const typesChanged = await this.writeIfChanged(
      typeOutputFilepath,
      typeOutputContent
    );

    debug(`Manifest saved to ${this.outputDir}`);

    if (spriteChanged || typesChanged) {
      success(`Packed '${files.length}' SVG icons successfully`);
    }
  }

  private iconName(file: string) {
    return file.replace(/\.svg$/, '');
  }

  /**
   * Creates a single SVG file that contains all the icons
   */
  private async generateSvgSprite({
    files,
    inputDir,
    outputPath,
  }: {
    files: string[];
    inputDir: string;
    outputPath: string;
  }) {
    // Each SVG becomes a symbol, and we wrap them all in a single SVG
    const symbols = await Promise.all(
      files.map(async (file) => {
        const input = await fs.readFile(path.join(inputDir, file), {
          encoding: 'utf8',
        });
        const root = parse(input);

        const svg = root.querySelector('svg');
        if (!svg) throw new Error('No SVG element found');

        svg.tagName = 'symbol';
        svg.setAttribute('id', this.iconName(file));
        svg.removeAttribute('xmlns');
        svg.removeAttribute('xmlns:xlink');
        svg.removeAttribute('version');
        svg.removeAttribute('width');
        svg.removeAttribute('height');

        return svg.toString().trim();
      })
    );

    const output = [
      `<?xml version="1.0" encoding="UTF-8"?>`,
      `<!-- ${comment} -->`,
      `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1" height="1">`,
      `<defs>`,
      ...symbols,
      `</defs>`,
      `</svg>`,
      '', // trailing newline
    ].join('\n');

    return this.writeIfChanged(outputPath, output);
  }

  private async writeIfChanged(filepath: string, newContent: string) {
    const currentContent = await fs
      .readFile(filepath, { encoding: 'utf8' })
      .catch(() => '');
    if (currentContent === newContent && !this.opts.force) {
      return false;
    }
    await fs.writeFile(filepath, newContent, { encoding: 'utf8' });
    // await $`prettier --write ${filepath} --ignore-unknown`;
    return true;
  }
}
